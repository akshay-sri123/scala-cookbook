---layout: pagetitle: なぜScalaを学ぶのかtagline:---{% include JB/setup %}### Scalaの良いところ* 関数型言語、オブジェクト指向言語(C++, Java)などの良いところを吸収している  * 関数定義のための簡潔な構文* Syntaxが簡潔（コードを短く書けるのは武器）* そのため、言語の不備と戦うための技術から解放される  * テンプレートによるHack (Modern C++ Design)  * デザインパターン     * VisitorパターンなどはScalaでは不要。パターンマッチを使えば良い* コレクションとその基本操作(map, filter, foldなど)が充実  * Javaで数百行必要なコードが数行にまとまることも珍しくない* pattern matchingで、簡単な場合分けが手軽に* 静的型付け言語。型情報を利用したデータ構造の最適化により速いコードが書ける* JVMの最適化などの恩恵がある* OS環境を問わないコードを書ける  * C++でwindow, mac, linuxでも動くコードを書くのは大変！* スレッドを使った並列プログラミングが手軽になる* Javaの資産が活きる  * 画像を描く、GUIアプリケーションを作る、ネットワーク通信、グラフを描く、データ圧縮など多数ライブラリがScalaでも使える* 以下のJavaの不便さを見事に解消している   * 冗長な構文  * checked exception(throws ...Exception) を考慮したクラス設計の難しさ  * 多重継承ができないために、実装を複数クラスで共有できない    * そのため、コレクションクラス間で共通にできそうな操作(map, fold, filterなど）が実装しにくく、提供すらされていない。Scalaではtraitで実装の共有が可能  * 関数に渡す関数（高階関数）を定義するのに、クラスを定義する必要があった(その場で使うコードに対して、近い位置に必要なコードを書けない)    * コードブロックを定義しにくかった  * クラスの定義が面倒 (constructor内で変数をbindする単調作業が多い)  * type erasureによって、オブジェクトの型が静的に決まらない場合への対処がある(ClassManifest, signatureなど)  * publicクラス毎にファイルを分ける必要があった  * switch ... break でbreak分を書き忘れるバグ* プログラマが頑張ればJavaでもできるが、Scalaのコンパイラが上記の言語の不備を補う仕事を代わりにやってくれる### Scalaの不便なところ* 起動、コンパイルがやや遅い* 書こうと思えば、読み難いコードが書けてしまう* SIMD命令など、CPUの特性を生かしたコードを書くためには、JNIなどを通す必要がある* メモリ管理に厳しさが必要なアプリケーション（ゲノムアセンブラなど）を書く場合、メモリ管理がライブラリ、JVMのGCの裏側に隠れてしまうので予測しにくい。  * しかし、それほど高度なプログラミングを必要とするアプリケーションは特殊  * 例えば、ゲノムのアラインメントなら、Scalaでも十分実用的な速さのコードが書ける